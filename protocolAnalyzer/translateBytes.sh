#!/bin/bash

#This sentence puts the 6th fields of bytes-files in SRCMACADDRESS variable
SRC_MAC=$(cat $pcap |tr  '\n' ' ' | awk '{print $1":" $2 ":" $3 ":" $4 ":" $5 ":" $6 }')

#This sentence puts the 7-12th fields in SRCMACADDRESS variable
DST_MAC=$(cat $pcap |tr  '\n' ' ' | awk '{print $7":" $8 ":" $9 ":" $10 ":" $11 ":" $12 }')

#This sentence puts the 6th fields of bytes-files in SRCMACADDRESS variable
SRC_MAC_VENDOR_ADDRESS=$(cat $pcap |tr  '\n' ' ' | awk '{print $1":" $2 ":" $3}')

#This sentence puts the 7-12th fields in SRCMACADDRESS variable
DST_MAC_VENDOR_ADDRESS=$(cat $pcap |tr  '\n' ' ' | awk '{print $7":" $8 ":" $9}')

#This command will look up for vendor in file "Vendor_MACs_Addrresses" and will put in SRC_MAC_VENDOR_NAME if match
#the grep -i --ignore the Upercases
SRC_MAC_VENDOR_NAME=$(cat Vendors-MACs-Addresses | grep -i $SRC_MAC_VENDOR_ADDRESS |cut -d" " -f2-)

#This command will look up for vendor in file "Vendor_MACs_Addrresses" and will put in DST_MAC_VENDOR_NAME if match
DST_MAC_VENDOR_NAME=$(cat Vendors-MACs-Addresses | grep -i $DST_MAC_VENDOR_ADDRESS |cut -d" " -f2-)

#This sentence puts the IP byte in IP_VERSION variable
PROTOCOL_ETHERNET_PAYLOAD=$(cat $pcap | tr '\n' ' ' | awk '{print $13 " " $14}')
echo "------------------------------------------"
echo "Getting the Ethernet header"
echo "------------------------------------------"
echo "SRC_MAC_VENDOR $SRC_MAC_VENDOR_ADDRESS > $SRC_MAC_VENDOR_NAME"
echo "DST_MAC_VENDOR $DST_MAC_VENDOR_ADDRESS > $DST_MAC_VENDOR_NAME"
echo "SRC_MAC $SRC_MAC"
echo "DST_MAC $DST_MAC"
#This  string comparation test if is ARP or IP in ehernet payload
echo""

	if test "$PROTOCOL_ETHERNET_PAYLOAD" = "08 00"
		then
			IP_VERSION=$(cat $pcap | tr '\n' ' ' | cut -d" " -f15 | cut -c1)
			echo "Ethernert Protocol  Payload > $PROTOCOL_ETHERNET_PAYLOAD"
			echo "------------------------------------------"
		else
			
			echo "Ethernert Protocol  Payload > $PROTOCOL_ETHERNET_PAYLOAD"
			echo "------------------------------------------"
	fi




#Get the IP Header length
IP_HEADER_LENGTH_BYTE=$(cat $pcap | tr '\n' ' ' | cut -d" " -f15 | cut -c2)

#Translating hexdacimal to decimal 
IP_HEADER_LENGTH=$(echo $(( 16#$IP_HEADER_LENGTH_BYTE )))

#In IP, each header have 4 byte, the byte 5, tell us , that have 5 times 4 bytes of leght the IP header
IP_HEADER_LENGTH=$(expr $IP_HEADER_LENGTH \* 4)  # 4 is the number of size pf each header in IP

#Type of service bytes
IP_TYPE_SERVICE=$(cat $pcap | tr '\n' ' ' | cut -d" " -f16)

#Packet Length
IP_PACKET_LENGTH_BYTES=$(cat $pcap | tr '\n' ' ' | cut -d" " -f17-18 | colrm 3 3)

#Translating hexdacimal to decimal 
IP_PACKET_LENGTH=$(echo $(( 16#$IP_PACKET_LENGTH_BYTES )))

#Packet ID bytes
IP_PACKET_ID_BYTES=$(cat $pcap | tr '\n' ' ' | cut -d" " -f19-20 | colrm 3 3)

#Translating hexdacimal to decimal 
IP_PACKET_ID=$(echo $(( 16#$IP_PACKET_ID_BYTES )))

#Flag-Degramentation or not
IP_FLAG=$(cat $pcap | tr '\n' ' ' | cut -d" " -f21 | cut -c 1)

#Fragment Offset bytes
IP_OFFSET_ID_BYTES=$(cat $pcap | tr '\n' ' ' | cut -d" " -f21-22 | cut -c 2- | colrm 2 2 | colrm 4 4)

#Fragment Offset
IP_OFFSET_ID=$(echo $(( 16#$IP_OFFSET_ID_BYTES )))

#Time ti live
IP_TTL_BYTES=$(cat $pcap | tr '\n' ' ' | cut -d" " -f23)
#Translating hexdacimal to decimal 
IP_TTL=$(echo $(( 16#$IP_TTL_BYTES )))

#Internet Payload Protocol - PROTOCOL
IP_PACKET_PAYLOAD_PROTOCOL=$(cat $1 | tr '\n' ' ' | cut -d" " -f24)

#Time ti live
IP_CHECKSUM_BYTES=$(cat $pcap | tr '\n' ' ' | cut -d" " -f25-26 | colrm 3 3)
#Translating hexdacimal to decimal 
IP_CHECKSUM=$(echo $(( 16#$IP_CHECKSUM_BYTES )))

#Source IP Addresses
IP_SRC_ADDRESS_BYTES[0]=$(cat $pcap | tr '\n' ' ' | cut -d" " -f27)
IP_SRC_ADDRESS_BYTES[1]=$(cat $pcap | tr '\n' ' ' | cut -d" " -f28)
IP_SRC_ADDRESS_BYTES[2]=$(cat $pcap | tr '\n' ' ' | cut -d" " -f29)
IP_SRC_ADDRESS_BYTES[3]=$(cat $pcap | tr '\n' ' ' | cut -d" " -f30)

#Translating hexdacimal to decimal 
IP_SRC_ADDRESS[0]=$(( 16#${IP_SRC_ADDRESS_BYTES[0]} ))
IP_SRC_ADDRESS[1]=$(( 16#${IP_SRC_ADDRESS_BYTES[1]} ))
IP_SRC_ADDRESS[2]=$(( 16#${IP_SRC_ADDRESS_BYTES[2]} ))
IP_SRC_ADDRESS[3]=$(( 16#${IP_SRC_ADDRESS_BYTES[3]} ))

#Destination IP Addresses
IP_DST_ADDRESS_BYTES[0]=$(cat $pcap | tr '\n' ' ' | cut -d" " -f31)
IP_DST_ADDRESS_BYTES[1]=$(cat $pcap | tr '\n' ' ' | cut -d" " -f32)
IP_DST_ADDRESS_BYTES[2]=$(cat $pcap | tr '\n' ' ' | cut -d" " -f33)
IP_DST_ADDRESS_BYTES[3]=$(cat $pcap | tr '\n' ' ' | cut -d" " -f34)

#Translating hexdacimal to decimal 
IP_DST_ADDRESS[0]=$(( 16#${IP_DST_ADDRESS_BYTES[0]} ))
IP_DST_ADDRESS[1]=$(( 16#${IP_DST_ADDRESS_BYTES[1]} ))
IP_DST_ADDRESS[2]=$(( 16#${IP_DST_ADDRESS_BYTES[2]} ))
IP_DST_ADDRESS[3]=$(( 16#${IP_DST_ADDRESS_BYTES[3]} ))


echo "------------------------------------------"
echo "Getting the IP Header"
echo "------------------------------------------"
echo "IP Version a > $IP_VERSION and $IP_VERSION"
echo "Header length >   $IP_HEADER_LENGTH_BYTE and $IP_HEADER_LENGTH"
echo "Type of service's bytes setted > $IP_TYPE_SERVICE_BYTES and $IP_TYPE_SERVICE"
echo "Packet Length bytes and decimal > $IP_PACKET_LENGTH_BYTES and  $IP_PACKET_LENGTH"
echo "Identification  > $IP_PACKET_ID_BYTES and $IP_PACKET_ID"
echo  "Flag > $IP_FLAG"
echo  "Offset > $IP_OFFSET_ID_BYTES and $IP_OFFSET_ID"
echo "Time to live byte and decimal > $IP_TTL_BYTES and "$IP_TTL
echo "Checksum number > $IP_CHECKSUM_BYTES  and $IP_CHECKSUM" 
echo "IP payload type in byte and name > $IP_PACKET_PAYLOAD_PROTOCOL" 
echo "IP source address bytes ${IP_SRC_ADDRESS_BYTES[0]} ${IP_SRC_ADDRESS_BYTES[1]} ${IP_SRC_ADDRESS_BYTES[2]} ${IP_SRC_ADDRESS_BYTES[3]}"
echo "IP source address decimal > ${IP_SRC_ADDRESS[0]}.${IP_SRC_ADDRESS[1]}.${IP_SRC_ADDRESS[2]}.${IP_SRC_ADDRESS[3]}"
echo "IP Destination  address bytes > ${IP_DST_ADDRESS_BYTES[0]} ${IP_DST_ADDRESS_BYTES[1]} ${IP_DST_ADDRESS_BYTES[2]} ${IP_DST_ADDRESS_BYTES[3]}"
echo "IP Destination address decima l> ${IP_DST_ADDRESS[0]}.${IP_DST_ADDRESS[1]}.${IP_DST_ADDRESS[2]}.${IP_DST_ADDRESS[3]}"

#Function to treat the TCP header's packet
function TCP_HEADER_FUNCTION {

#Getting the source port of packet's bytes
SRC_PORT_BYTES=$(cat $pcap | tr '\n' ' ' | cut -d" " -f35-36 | colrm 3 3 )
SRC_PORT=$(( 16#$SRC_PORT_BYTES ))

#Getting the destination port of packet's bytes
DST_PORT_BYTES=$(cat $pcap | tr '\n' ' ' | cut -d" " -f37-38 | colrm 3 3 )
DST_PORT=$(( 16#$DST_PORT_BYTES ))

#Getting the sequence number 
TCP_SEQUENCE_NUMBER_BYTES=$(cat $pcap | tr '\n' ' ' | cut -d" " -f39-42| colrm 3 3 | colrm 5 5 | colrm 7 7)

#Translating hexdacimal to decimal 
TCP_SEQUENCE_NUMBER=$(echo $(( 16#$TCP_SEQUENCE_NUMBER_BYTES )))

#Getting Acknowledgement number 
TCP_ACKNOWLEDGEMENT_NUMBER_BYTES=$(cat $pcap | tr '\n' ' ' | cut -d" " -f43-46 | colrm 3 3 | colrm 5 5 | colrm 7 7)

#Translating hexdacimal to decimal 
TCP_ACKNOWLEDGEMENT_NUMBER=$(echo $(( 16#$TCP_ACKNOWLEDGEMENT_NUMBER_BYTES )))

#Getting the data offset
DATA_OFFSET_BYTE=$(cat $pcap | tr '\n' ' ' | cut -d" " -f47 | cut -c 1)

#Translating hexdacimal to decimal 
DATA_OFFSET=$(echo $(( 16#$DATA_OFFSET_BYTE )))

#Getting Reserved
RESERVED_BYTE=$(cat $pcap | tr '\n' ' ' | cut -d" " -f47 | cut -c 2-)

#Translating hexdacimal to decimal 
RESERVED=$(echo $(( 16#$RESERVED_BYTE )))

#Getting the Byte flag
ARRAY_TCP_FLAG_BYTES=$(cat $pcap | tr '\n' ' ' | cut -d" " -f48)

#Getting the decimal flag
TCP_FLAG_BYTES=$(echo $(( 16#$ARRAY_TCP_FLAG_BYTES )))

#TCP flag's function
function TCP_FLAG_FUNCTION {

	#Flags and its value default
	#URG=32 #ACK=16 #PUSH=8 #RST=4 #SYN=2 #FIN=1
	
	#setting the specif method for the TCP_FLAG
if test "$TCP_FLAG_BYTES" -eq 1
	then TCP_FLAG="fin"
	elif test "$TCP_FLAG_BYTES" -eq 2
	then TCP_FLAG="syn"
	elif test "$TCP_FLAG_BYTES" -eq 3
	then TCP_FLAG="fin and syn"
	elif test "$TCP_FLAG_BYTES" -eq 4
	then TCP_FLAG="rst"
	elif test "$TCP_FLAG_BYTES" -eq 5
	then TCP_FLAG="rst and fin"
	elif test "$TCP_FLAG_BYTES" -eq 6
	then TCP_FLAG="rst  and syn"
	elif test "$TCP_FLAG_BYTES" -eq 7
	then TCP_FLAG="rst, syn and fin"
	elif test "$TCP_FLAG_BYTES" -eq 8
	then TCP_FLAG="psh"
	elif test "$TCP_FLAG_BYTES" -eq 9
	then TCP_FLAG="psh and fin"
	elif test "$TCP_FLAG_BYTES" -eq 10
	then TCP_FLAG="psh and syn"
	elif test "$TCP_FLAG_BYTES" -eq 11
	then TCP_FLAG="psh, syn and fyn"
	elif test "$TCP_FLAG_BYTES" -eq 12
	then TCP_FLAG="psh and rst"
	elif test "$TCP_FLAG_BYTES" -eq 13
	then TCP_FLAG="psh, rst and fin"
	elif test "$TCP_FLAG_BYTES" -eq 14
	then TCP_FLAG="psh, rst and syn"	
	elif test "$TCP_FLAG_BYTES" -eq 15
	then TCP_FLAG="psh, rst and syn and fin"	
	elif test "$TCP_FLAG_BYTES" -eq 16
	then TCP_FLAG="ack"
	elif test "$TCP_FLAG_BYTES" -eq 17
	then TCP_FLAG="ack and fin"
	elif test "$TCP_FLAG_BYTES" -eq 18
	then TCP_FLAG="ack and syn"
	elif test "$TCP_FLAG_BYTES" -eq 19
	then TCP_FLAG="ack, syn and fin"
	elif test "$TCP_FLAG_BYTES" -eq 20
	then TCP_FLAG="ack and rst"
	elif test "$TCP_FLAG_BYTES" -eq 21
	then TCP_FLAG="ack, rst and fin"
	elif test "$TCP_FLAG_BYTES" -eq 22
	then TCP_FLAG="ack,  rst and syn"
	elif test "$TCP_FLAG_BYTES" -eq 23
	then TCP_FLAG="ack,  rst,  syn and fin"
	elif test "$TCP_FLAG_BYTES" -eq 24
	then TCP_FLAG="ack and push"
	elif test "$TCP_FLAG_BYTES" -eq 25
	then TCP_FLAG="ack, push and fin"
	elif test "$TCP_FLAG_BYTES" -eq 26
	then TCP_FLAG="ack, push and syn"
	elif test "$TCP_FLAG_BYTES" -eq 27
	then TCP_FLAG="ack, push , syn and fin"
	elif test "$TCP_FLAG_BYTES" -eq 28
	then TCP_FLAG="ack, push and rst"
	elif test "$TCP_FLAG_BYTES" -eq 29
	then TCP_FLAG="ack, push, rst and fin"
	elif test "$TCP_FLAG_BYTES" -eq 30
	then TCP_FLAG="ack, push, rst and syn"
	elif test "$TCP_FLAG_BYTES" -eq 31
	then TCP_FLAG="ack, push, rst, syn and syn"
	elif test "$TCP_FLAG_BYTES" -eq 32
	then TCP_FLAG="urg"
	elif test "$TCP_FLAG_BYTES" -eq 33
	then TCP_FLAG="urg and fin"
	elif test "$TCP_FLAG_BYTES" -eq 34
	then TCP_FLAG="urg and syn"
	elif test "$TCP_FLAG_BYTES" -eq 35
	then TCP_FLAG="urg, syn and fin"
	elif test "$TCP_FLAG_BYTES" -eq 36
	then TCP_FLAG="urg and rst"
	elif test "$TCP_FLAG_BYTES" -eq 37	
	then TCP_FLAG="urg, rst and fin"	
	elif test "$TCP_FLAG_BYTES" -eq 38
	then TCP_FLAG="urg, rst and syn"	
	elif test "$TCP_FLAG_BYTES" -eq 39
	then TCP_FLAG="urg, rst, syn and  fin"
	elif test "$TCP_FLAG_BYTES" -eq 40
	then TCP_FLAG="urg and psh"
	elif test "$TCP_FLAG_BYTES" -eq 41
	then TCP_FLAG="urg, psh and fin"
	elif test "$TCP_FLAG_BYTES" -eq 42
	then TCP_FLAG="urg, psh and syn"
	elif test "$TCP_FLAG_BYTES" -eq 43
	then TCP_FLAG="urg, psh, syn and fin"
	elif test "$TCP_FLAG_BYTES" -eq 44
	then TCP_FLAG="urg, psh, and rst"
	elif test "$TCP_FLAG_BYTES" -eq 45
	then TCP_FLAG="urg, psh,  rst and fin"
	elif test "$TCP_FLAG_BYTES" -eq 46
	then TCP_FLAG="urg, psh,  rst and syn"
	elif test "$TCP_FLAG_BYTES" -eq 47
	then TCP_FLAG="urg, psh,  rst, syn and fin"
	elif test "$TCP_FLAG_BYTES" -eq 48
	then TCP_FLAG="urg and ack"
	elif test "$TCP_FLAG_BYTES" -eq 49	
	then TCP_FLAG="urg, ack and fin"
	elif test "$TCP_FLAG_BYTES" -eq 50
	then TCP_FLAG="urg, ack and syn"
	elif test "$TCP_FLAG_BYTES" -eq 51
	then TCP_FLAG="urg, ack,  syn and fin"
	elif test "$TCP_FLAG_BYTES" -eq 52
	then TCP_FLAG="urg, ack, and rst"
	elif test "$TCP_FLAG_BYTES" -eq 53
	then TCP_FLAG="urg, ack, rst and fin"
	elif test "$TCP_FLAG_BYTES" -eq 54
	then TCP_FLAG="urg, ack, rst and syn"
	elif test "$TCP_FLAG_BYTES" -eq 55
	then TCP_FLAG="urg, ack, rst, syn and fin"
	elif test "$TCP_FLAG_BYTES" -eq 56
	then TCP_FLAG="urg, ack, psh"
	elif test "$TCP_FLAG_BYTES" -eq 57
	then TCP_FLAG="urg, ack, psh and fin"
	elif test "$TCP_FLAG_BYTES" -eq 58
	then TCP_FLAG="urg, ack, psh and syn"
	elif test "$TCP_FLAG_BYTES" -eq 59	
	then TCP_FLAG="urg, ack, psh and syn and fin"
	elif test "$TCP_FLAG_BYTES" -eq 60
	then TCP_FLAG="urg, ack, push , and rst"	
	elif test "$TCP_FLAG_BYTES" -eq 61
	then TCP_FLAG="urg, ack, push,  rst and fin"	
	elif test "$TCP_FLAG_BYTES" -eq 62	
	then TCP_FLAG="urg, ack, push, rst and syn"	
	elif test "$TCP_FLAG_BYTES" -eq 63
	then TCP_FLAG="urg, ack, psh, rst, syn and fin"
	else
	echo "Nothing have $TCP_FLA_BYTES dont have matched"
	fi

	echo "$TCP_FLAG"
#End of TCP_FLAG_FUNCTION
} 

#Getting the windows size to control 
TCP_WINDOWS_SIZE_BYTES=$(cat $1 | tr '\n' ' ' | cut -d" " -f49-50 | colrm 3 3)

#Translating hexdacimal to decimal 
TCP_WINDOWS_SIZE=$(echo $(( 16#$TCP_WINDOWS_SIZE_BYTES )))

#Getting the checksum 
TCP_CHECKSUM_BYTES=$(cat $1 | tr '\n' ' ' | cut -d" " -f51-52 | colrm 3 3)

#Translating hexdacimal to decimal 
TCP_CHECKSUM=$(echo $(( 16#$TCP_CHECKSUM_BYTES )))

#Getting the Urgent pointer 
TCP_URGENT_POINTER_BYTES=$(cat $pcap | tr '\n' ' ' | cut -d" " -f53-54 | colrm 3 3)

#Translating hexdacimal to decimal 
TCP_URGENT_POINTER=$(echo $(( 16#$TCP_URGENT_POINTER_BYTES )))

#Getting the Payload 
ARRAY_TCP_PAYLOAD_BYTES=$(cat $pcap | tr '\n' ' ' | cut -d" " -f55- |  awk '{print $0}')

#Getting the list eg (50 14 00 00 4a e6 00 00 00 00 00 00 00 00 )
TCP_PAYLOAD_BYTES=$ARRAY_TCP_PAYLOAD_BYTES

#function to get the bytes, translate in ASCII and put inside the array
function TCP_PAYLOAD_FUNCTION {

#Loop whith for to get the list of fiels and after translate for ASCII
for x in  $TCP_PAYLOAD_BYTES
	do
		echo -ne "\x$x"
	done

#End of TCP_PAYLOAD_FUNCTION
}

echo "------------------------------------------"
echo "Getting the TCP Header"
echo "------------------------------------------"
echo "The soure PORT > $SRC_PORT_BYTES  and $SRC_PORT"
echo "The destination PORT >$DST_PORT_BYTES and $DST_PORT"
echo "The sequence number >$TCP_SEQUENCE_NUMBER_BYTES and $TCP_SEQUENCE_NUMBER"
echo "The acknowledgement number > $TCP_ACKNOWLEDGEMENT_NUMBER_BYTES and $TCP_ACKNOWLEDGEMENT_NUMBER"
echo "Packet Offset sequence number > $DATA_OFFSET_BYTE and $DATA_OFFSET"
echo "The reserved number > $RESERVED_BYTES and $RESERVED"
echo -n "The flag number > $_TCP_FLAG_BYTES  -- "; TCP_FLAG_FUNCTION; 
echo "The windows size > $TCP_WINDOWS_SIZE_BYTES $TCP_WINDOWS_SIZE" 
echo "The checksum number > $TCP_CHECKSUM_BYTES and $TCP_CHECKSUM"
echo "The Urgent Pointer > $TCP_URGENT_POINTER_BYTES and $TCP_URGENT_POINTER"
echo "The payload > " ; TCP_PAYLOAD_FUNCTION

# End of TCP_HEADER_FUNCTION
}

if test "$IP_PACKET_PAYLOAD_PROTOCOL" = "06"
then 
	echo ""
	echo "The protocol number > $IP_PACKET_PAYLOAD_PROTOCOL"
	echo "------------------------------------------"
	TCP_HEADER_FUNCTION $pcap
else 
	echo "other protocol"
fi	


